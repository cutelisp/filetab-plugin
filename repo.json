[
	{
		"Name": "filetab",
		"Description": "File manager for Micro",
		"Tags": ["filetab", "filemanager", "file", "manager"],
		"Versions": [
			{

			}
		]
	}
]


-- Returns true/false if the file is a dotfile
local function is_dotfile(file_name)

-- Check if the filename starts with a dot
if string.sub(file_name, 1, 1) == '.' then
return true
else
return false
end
end


function refresh_and_select()
-- Save the cursor position before messing with the view..
-- because changing get_content in the view causes the Y loc to move
local last_y = tree_view.Cursor.Loc.Y
-- Actually refresh
tab:view_refresh()
-- Moves the cursor back to it's original position
self.select_line(tree_view, last_y)
end



-- Hightlights the line when you move the cursor up/down
 function Tab:select_line(line_number)

	line_number = 2
	-- Make last_y optional
	if line_number then
		-- Don't let them move past ".." by checking the result first
		if line_number > 1 then
			-- If the last position was valid, move back to it
			self.curPane.Cursor.Loc.Y = line_number
		end
	elseif line_number < 2 then
		-- Put the cursor on the ".." if it's above it
		self.curPane.Cursor.Loc.Y = 2
	end

	-- Puts the cursor back in bounds (if it isn't) for safety
	self.curPane.Cursor:Relocate()

	-- Makes sure the cursor is visible (if it isn't)
	-- (false) means no callback
	self.curPane:Center()

	-- Highlight the current line where the cursor is
	self.curPane.Cursor:SelectLine()
end



-- Opens the dir's get_content nested under itself
function Tab:uncompress_target(target_entry_y) 
	-- Exit early if given entry_y is a header entry or entry is not a directory
	if not self.entry_list[target_entry_y].is_dir or self.entry_list[target_entry_y].is_open or target_entry_y < 2then
		return
	end

	-- Get a new scanlist with results from the scan in the target dir
	local target_entry_list = self:get_entry_list(self.entry_list[target_entry_y].abs_path, target_entry_y, self.entry_list[target_entry_y].indent_level + 1)
	
	utils.insert_table_into_table(self.entry_list, target_entry_list, target_entry_y )







	-- Check if we actually need to resize, or if we're nesting at the same indent
	-- Also check if there's anything in the dir, as we don't need to expand on an empty dir
	if scan_results ~= nil then
		if self.entry_list[target_entry_y].indent_level > 10 and #scan_results >= 1 then
			-- Save the new highest indent
			--highest_visible_indent = self.entry_list[entry_y].indent_level
			-- Increase the width to fit the new nested content
			self:resize(tree_view:GetView().Width + self.entry_list[target_entry_y].indent_level)
		end
	end

	self.entry_list[target_entry_y]:set_is_open(true)
	self:view_refresh()
	
end







-- If we should not show dotfiles, and this is a dotfile, don't show
if false or  show_dotfiles and utils.is_dotfile(file_name) then
showfile = false
end
-- If we should not show ignored files, and this is an ignored file, don't show
if false or not show_ignored and utils.is_entry_in_table(file_name, all_files) then
showfile = false
end




-- Newlines are needed for all inserts except the last (so it does not leave a blank spot at the bottom)
-- Insert line-by-line to avoid out-of-bounds on big folders
-- +2 so we skip the 0/1/2 header positions
-- Concatenate all lines and insert them at once
function View:print_entries(entry_list,s, offset)
	local entry_content
	local lines = {}
    offset = offset or 0 
	for i = 1, entry_list:size() - 1 do
		entry_content = entry_list:get_entry(i):get_content(offset) .. self.test
		lines[#lines + 1] = entry_content .. (i < entry_list:size() and '\n' or '')

        if entry_list:get_entry(i).is_open then
            buf = s.Buf
            endLoc = s.Buf:End()  -- Obtém a localização do final do buffer


            self.pane.Buf.EventHandler:Insert(utils.get_buffer_end(s), table.concat(lines))

            self.test = 22

            self:print_entries(entry_list:get_entry(i):get_entry_list(), s, offset + 1)
            local lines = {}
        end
	end
    newLineLoc = buffer.Loc(0, s.Buf:End().Y + 0)

    self.pane.Buf.EventHandler:Insert(utils.get_buffer_end(s), table.concat(self.entry_list:get_content()))---table.concat(lines)
end




-- Structures the output of the scanned directory content to be used in the scanlist table
-- This is useful for both initial creation of the tree, and when nesting with uncompress_target()
function Tab:get_entry_list(directory, ownership, indent_level)
	----local show_dotfiles = config.GetGlobalOption('filemanager.showdotfiles')
	--local show_ignored_files = config.GetGlobalOption('filemanager.showignored') --TODO not working ignored_files not fetching correctly ig
	a = Entry_list:new(directory, 0, 0 )
	-- Gets a list of all the files names in the current dir
	local all_files_names, error_message = utils.get_files_names(directory, true, true)

	-- files will be nil if the directory is read-protected (no permissions)
	if all_files_names == nil then
		micro.InfoBar():Error('Error scanning dir: ', directory, ' | ', error_message)
		return nil
	end

	-- The list of directories & files entries to be returned (and eventually put in the view)
	local entries_directories = {}
	local entries_files = {}
	local entry_name

	for i = 1, #all_files_names do
		entry_name = all_files_names[i]

		local new_entry = Entry:new(entry_name, filepath.Join(directory, entry_name), ownership, indent_level)

		-- Logic to make sure all directories are appended first to entries table so they are shown first
		if not new_entry.is_dir then
			-- If this is a file, add it to (temporary) files
			entries_files[#entries_files + 1] = new_entry
		else
			-- Otherwise, add to entries
			entries_directories[#entries_directories + 1] = new_entry
		end
	end

	-- Append all file entries to directories entries (So they can be correctly sorted)
	utils.get_appended_tables(entries_directories, entries_files)

	-- Return all entries (directories + files)
	return entries_directories
end

-- Opens the dir's get_content nested under itself
function Tab:expand_directory_at_cursor() 

	--entry = self.entry_list:get_entry(4) --view:get_cursor_y()
	-- Exit early if given entry_y is a header entry or entry is not a directory
	--if false and not entry.is_dir or entry.is_open then -- todo header check
--		return
	--end

	--self.entry_list:get_entry(4).entry_list = Entry_list:new(entry.abs_path, 0,0)
	self.entry_list:get_entry(6).entry_list = Entry_list:new(self.entry_list:get_entry(6).abs_path, 0,0)

	micro.InfoBar():Error(self.entry_list:get_entry(6).entry_list:get_entry(2).file_name)

	--entry:set_is_open(true)

	-- Check if we actually need to resize, or if we're nesting at the same indent
	-- Also check if there's anything in the dir, as we don't need to expand on an empty dir
	if false and scan_results ~= nil then
		if self.entry_list[target_entry_y].indent_level > 10 and #scan_results >= 1 then
			-- Save the new highest indent
			--highest_visible_indent = self.entry_list[entry_y].indent_level
			-- Increase the width to fit the new nested content
			self:resize(tree_view:GetView().Width + self.entry_list[target_entry_y].indent_level)
		end
	end
	self.entry_list:get_entry(6):set_is_open(true)
	--view:print(self.entry_list:get_entry(6).entry_list.list)
	--entry:set_is_open(true)
	--self:view_refresh()
	
end




-- Tries to load the given entry_y according to entry_list
-- If it's the top directory indicator, or separator, nothing happens
-- If it's ".." then it tries to go back a directory level
-- If it's a directory then it loads the directory
-- If it's actually a file, open it in a new vsplit --todo
-- THIS EXPECTS ZERO-BASED Y
 function Tab:load_entry(entry_y, direction)
	-- 2 is the zero-based index of ".."
	if entry_y == 2 then
		self:load_back_directory()
	elseif entry_y > 2 and not self:is_entry_list_empty() then
		entry_y = entry_y - 2 -- -2 to conform to our entry_list "missing" first 3 indicies (header)
		if self.entry_list[entry_y].is_dir then -- Directory
			self:load(self.entry_list[entry_y].abs_path)
		else -- File todo
			-- If it's a file, then open it
			micro.InfoBar():Message('filemanager opened ', tab.entry_list[entry_y].abs_path)
			if direction == 'vsplit' then
				-- Opens the absolute path in new vertical view
				micro.CurPane():VSplitIndex(buffer.NewBufferFromFile(tab.entry_list[y].abs_path), true)
			else
				-- Opens the absolute path in new horizontal view
				micro.CurPane():HSplitIndex(buffer.NewBufferFromFile(tab.entry_list[y].abs_path), true)
			end
			-- Resizes all views after opening a file
			-- tabs[curTab + 1]:Resize()
		end
	else
		micro.InfoBar():Error('Can\'t open that')
	end
end